import { Actor, HttpAgent, Identity } from '@icp-sdk/core/agent';
import { Principal } from '@icp-sdk/core/principal';

// These would normally be generated by icp-cli tooling. For now, use inline IDL.
// In a real deployment, import from declarations.

export const REGISTRY_CANISTER_ID =
  import.meta.env.VITE_REGISTRY_CANISTER_ID || 'bkyz2-fmaaa-aaaaa-qaaaq-cai';
const IC_HOST = import.meta.env.VITE_IC_HOST || 'https://ic0.app';

export function isLocalHost(host: string): boolean {
  try {
    const hostname = new URL(host).hostname;
    return hostname === 'localhost' || hostname === '127.0.0.1';
  } catch {
    return false;
  }
}

export function createAgent(identity: Identity): HttpAgent {
  const agent = HttpAgent.createSync({
    identity,
    host: IC_HOST,
    shouldFetchRootKey: isLocalHost(IC_HOST),
  });

  // The local replica does not support the /api/v4/ sync call endpoint and
  // returns 400 instead of 404, which prevents the SDK's automatic fallback.
  // Force all calls through /api/v2/ when running against localhost.
  if (isLocalHost(IC_HOST)) {
    const originalCall = agent.call.bind(agent);
    agent.call = (canisterId: any, options: any, identity?: any) =>
      originalCall(canisterId, { ...options, callSync: false }, identity);
  }

  return agent;
}

// Minimal Registry IDL factory
export const registryIdlFactory = ({ IDL }: { IDL: any }) => {
  const EngramRecord = IDL.Record({
    owner: IDL.Principal,
    canisterId: IDL.Principal,
    createdAt: IDL.Int,
    lastTopUp: IDL.Int,
    status: IDL.Variant({ Active: IDL.Null, Frozen: IDL.Null, Deleted: IDL.Null }),
  });

  const TopUpEvent = IDL.Record({
    timestamp: IDL.Int,
    token: IDL.Text,
    amountPaid: IDL.Nat,
    cyclesAmount: IDL.Nat,
    platformFee: IDL.Nat,
  });

  const EngramAccountingRecord = IDL.Record({
    owner: IDL.Principal,
    canisterId: IDL.Principal,
    totalCyclesTopUp: IDL.Nat,
    topUpHistory: IDL.Vec(TopUpEvent),
  });

  const TreasuryRecord = IDL.Record({
    totalIcpReceivedE8s: IDL.Nat,
    totalCyclesAllocated: IDL.Nat,
    platformFeeE8s: IDL.Nat,
    operationalFundE8s: IDL.Nat,
    lastUpdated: IDL.Int,
  });

  return IDL.Service({
    createEngram: IDL.Func(
      [],
      [IDL.Variant({ Ok: IDL.Record({ canisterId: IDL.Principal }), Err: IDL.Text })],
      [],
    ),
    topUpEngram: IDL.Func(
      [],
      [IDL.Variant({ Ok: IDL.Record({ newCyclesBalance: IDL.Nat }), Err: IDL.Text })],
      [],
    ),
    getMyEngram: IDL.Func([], [IDL.Opt(EngramRecord)], ['query']),
    getEngramByCanisterId: IDL.Func([IDL.Principal], [IDL.Opt(EngramRecord)], ['query']),
    listEngrams: IDL.Func(
      [IDL.Nat, IDL.Nat],
      [IDL.Record({ engrams: IDL.Vec(EngramRecord), total: IDL.Nat })],
      ['query'],
    ),
    status: IDL.Func(
      [],
      [
        IDL.Record({
          totalEngrams: IDL.Nat,
          activeEngrams: IDL.Nat,
          registryVersion: IDL.Text,
          engramWasmHash: IDL.Text,
          treasurySummary: IDL.Record({
            totalIcpReceivedE8s: IDL.Nat,
            totalCyclesAllocated: IDL.Nat,
          }),
          cycleReserve: IDL.Nat,
        }),
      ],
      ['query'],
    ),
    getEngramWasmHash: IDL.Func([], [IDL.Text], ['query']),
    // Treasury & top-up
    getMyDepositAddress: IDL.Func(
      [],
      [IDL.Record({ owner: IDL.Principal, subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)) })],
      ['query'],
    ),
    topUpEngramWithIcp: IDL.Func(
      [],
      [
        IDL.Variant({
          Ok: IDL.Record({ cyclesDeposited: IDL.Nat, icpChargedE8s: IDL.Nat }),
          Err: IDL.Text,
        }),
      ],
      [],
    ),
    getTreasury: IDL.Func([], [TreasuryRecord], ['query']),
    getMyEngramAccounting: IDL.Func([], [IDL.Opt(EngramAccountingRecord)], ['query']),
    // Changelog
    addChangelogEntry: IDL.Func(
      [IDL.Text, IDL.Text],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    getChangelog: IDL.Func(
      [],
      [
        IDL.Vec(
          IDL.Record({
            version: IDL.Text,
            wasmHash: IDL.Text,
            releaseNotes: IDL.Text,
            timestamp: IDL.Int,
          }),
        ),
      ],
      ['query'],
    ),
    // Sovereignty
    claimSovereignty: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    returnToManaged: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    getSovereigntyStatus: IDL.Func(
      [],
      [IDL.Variant({ Managed: IDL.Null, Sovereign: IDL.Null, Unknown: IDL.Text })],
      [],
    ),
    // Upgrades
    upgradeMyEngram: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    upgradeEngram: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    getCanonicalOperator: IDL.Func([], [IDL.Principal], ['query']),
    // Platform fee
    getPlatformFeeBps: IDL.Func([], [IDL.Nat], ['query']),
    setPlatformFeeBps: IDL.Func([IDL.Nat], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    // Stablecoin top-up (ckUSDC / ckUSDT)
    topUpEngramWithCkusdc: IDL.Func(
      [],
      [
        IDL.Variant({
          Ok: IDL.Record({
            cyclesDeposited: IDL.Nat,
            stablecoinChargedE6s: IDL.Nat,
            token: IDL.Text,
          }),
          Err: IDL.Text,
        }),
      ],
      [],
    ),
    topUpEngramWithStablecoin: IDL.Func(
      [IDL.Text],
      [
        IDL.Variant({
          Ok: IDL.Record({
            cyclesDeposited: IDL.Nat,
            stablecoinChargedE6s: IDL.Nat,
            token: IDL.Text,
          }),
          Err: IDL.Text,
        }),
      ],
      [],
    ),
    // Depeg protection
    setMaxDepegBps: IDL.Func([IDL.Nat], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    getMaxDepegBps: IDL.Func([], [IDL.Nat], ['query']),
    // Exchange rate
    getIcpUsdRate: IDL.Func(
      [],
      [IDL.Record({ rate: IDL.Nat64, decimals: IDL.Nat32, updatedAt: IDL.Int })],
      ['query'],
    ),
    // Metrics
    publicMetrics: IDL.Func(
      [],
      [
        IDL.Record({
          totalEngrams: IDL.Nat,
          activeEngrams: IDL.Nat,
          uniqueOwners: IDL.Nat,
          sovereignEngrams: IDL.Nat,
          registrySince: IDL.Int,
          totalCyclesAllocated: IDL.Nat,
        }),
      ],
      ['query'],
    ),
    privateMetrics: IDL.Func(
      [],
      [
        IDL.Variant({
          Ok: IDL.Record({
            totalEngrams: IDL.Nat,
            activeEngrams: IDL.Nat,
            uniqueOwners: IDL.Nat,
            sovereignEngrams: IDL.Nat,
            registrySince: IDL.Int,
            totalCyclesAllocated: IDL.Nat,
            totalIcpReceivedE8s: IDL.Nat,
            platformFeeE8s: IDL.Nat,
            operationalFundE8s: IDL.Nat,
            totalTopUpEvents: IDL.Nat,
            cycleReserve: IDL.Nat,
            platformFeeBps: IDL.Nat,
            maxDepegBps: IDL.Nat,
            registryVersion: IDL.Text,
            engramWasmHash: IDL.Text,
            treasuryLastUpdated: IDL.Int,
          }),
          Err: IDL.Text,
        }),
      ],
      ['query'],
    ),
    addMetricsViewer: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    removeMetricsViewer: IDL.Func(
      [IDL.Principal],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    listMetricsViewers: IDL.Func([], [IDL.Vec(IDL.Principal)], ['query']),
    // Treasury ledger & snapshots
    getSnapshots: IDL.Func(
      [IDL.Int, IDL.Int],
      [
        IDL.Variant({
          Ok: IDL.Vec(
            IDL.Record({
              timestamp: IDL.Int,
              totalCyclesAllocated: IDL.Nat,
              totalIcpReceivedE8s: IDL.Nat,
              platformFeeE8s: IDL.Nat,
              operationalFundE8s: IDL.Nat,
              cycleReserve: IDL.Nat,
              totalEngrams: IDL.Nat,
              activeEngrams: IDL.Nat,
              uniqueOwners: IDL.Nat,
              sovereignEngrams: IDL.Nat,
              totalTopUpEvents: IDL.Nat,
              periodCycles: IDL.Nat,
              periodIcpE8s: IDL.Nat,
              periodFeeE8s: IDL.Nat,
              periodEvents: IDL.Nat,
            }),
          ),
          Err: IDL.Text,
        }),
      ],
      ['query'],
    ),
    getTreasuryLedger: IDL.Func(
      [IDL.Int, IDL.Nat],
      [
        IDL.Variant({
          Ok: IDL.Vec(
            IDL.Record({
              id: IDL.Nat,
              timestamp: IDL.Int,
              kind: IDL.Variant({
                EngramCreated: IDL.Null,
                TopUpCycles: IDL.Null,
                TopUpIcp: IDL.Null,
                TopUpCkusdc: IDL.Null,
                TopUpCkusdt: IDL.Null,
              }),
              engram: IDL.Principal,
              gross: IDL.Nat,
              cycles: IDL.Nat,
              fee: IDL.Nat,
            }),
          ),
          Err: IDL.Text,
        }),
      ],
      ['query'],
    ),
    setSnapshotInterval: IDL.Func([IDL.Int], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    // Admin
    setAdmin: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
  });
};

// Minimal Engram IDL factory
export const engramIdlFactory = ({ IDL }: { IDL: any }) => {
  const Account = IDL.Record({ owner: IDL.Principal, subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)) });
  const OperatorPermissions = IDL.Record({
    canReadMemory: IDL.Bool,
    canAppendMemory: IDL.Bool,
    canReadSessions: IDL.Bool,
    canAppendSessions: IDL.Bool,
    canSearchMemory: IDL.Bool,
    canReadConfig: IDL.Bool,
    canReadWallet: IDL.Bool,
    canTransferFunds: IDL.Bool,
    dailySpendingLimitE8s: IDL.Nat,
    allowlistedAddresses: IDL.Vec(Account),
    callsPerMinute: IDL.Nat,
    maxSessionTTLNanos: IDL.Int,
  });
  const OperatorRecord = IDL.Record({
    principal: IDL.Principal,
    name: IDL.Text,
    registeredAt: IDL.Int,
    lastSeen: IDL.Int,
    permissions: OperatorPermissions,
    status: IDL.Variant({ Active: IDL.Null, Revoked: IDL.Null, Expired: IDL.Null }),
    publicKeyHash: IDL.Opt(IDL.Text),
    keyRotatedAt: IDL.Int,
    keyRotationCount: IDL.Nat,
  });
  const GuardianPermissions = IDL.Record({
    canRevokeOperators: IDL.Bool,
    canFreezePayments: IDL.Bool,
    canPauseWrites: IDL.Bool,
  });
  const GuardianRecord = IDL.Record({
    principal: IDL.Principal,
    name: IDL.Text,
    addedAt: IDL.Int,
    permissions: GuardianPermissions,
    status: IDL.Variant({ Pending: IDL.Null, Active: IDL.Null }),
  });
  const AgentIdentity = IDL.Record({
    ethAddress: IDL.Opt(IDL.Text),
    derivationPath: IDL.Opt(IDL.Vec(IDL.Nat8)),
    createdAt: IDL.Int,
  });
  const PaymentAuthorization = IDL.Record({
    from: IDL.Text,
    to: IDL.Text,
    value: IDL.Nat,
    validAfter: IDL.Int,
    validBefore: IDL.Int,
    nonce: IDL.Text,
    signature: IDL.Text,
  });
  const VerificationLevel = IDL.Variant({ Orb: IDL.Null, Device: IDL.Null, Document: IDL.Null });
  const WorldIdProof = IDL.Record({
    nullifierHash: IDL.Text,
    merkleRoot: IDL.Text,
    proof: IDL.Text,
    verificationLevel: VerificationLevel,
    verifiedAt: IDL.Int,
  });
  const MemoryFile = IDL.Record({
    path: IDL.Text,
    content: IDL.Text,
    version: IDL.Nat,
    lastModifiedBy: IDL.Principal,
    lastModifiedAt: IDL.Int,
    isIdentityFile: IDL.Bool,
  });
  const MemoryVersion = IDL.Record({
    version: IDL.Nat,
    modifiedBy: IDL.Principal,
    modifiedAt: IDL.Int,
    operation: IDL.Variant({ Set: IDL.Null, Append: IDL.Null, Rollback: IDL.Null }),
    contentSnapshot: IDL.Text,
  });
  const SessionMessage = IDL.Record({
    role: IDL.Variant({ User: IDL.Null, Assistant: IDL.Null, System: IDL.Null, Tool: IDL.Null }),
    content: IDL.Text,
    timestamp: IDL.Int,
  });
  const SessionInfo = IDL.Record({
    sessionKey: IDL.Text,
    messageCount: IDL.Nat,
    firstMessage: IDL.Int,
    lastMessage: IDL.Int,
  });
  const SearchResult = IDL.Record({
    path: IDL.Text,
    snippet: IDL.Text,
    score: IDL.Float64,
    startLine: IDL.Nat,
  });
  const AuditEntry = IDL.Record({
    id: IDL.Nat,
    timestamp: IDL.Int,
    caller: IDL.Principal,
    callerRole: IDL.Variant({ Owner: IDL.Null, Operator: IDL.Null, Guardian: IDL.Null }),
    operation: IDL.Text,
    details: IDL.Text,
    success: IDL.Bool,
  });
  const AgentConfig = IDL.Record({
    name: IDL.Text,
    model: IDL.Text,
    systemPrompt: IDL.Opt(IDL.Text),
    skills: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text)),
    preferences: IDL.Vec(IDL.Tuple(IDL.Text, IDL.Text)),
  });
  const BackupType = IDL.Variant({
    FullSnapshot: IDL.Null,
    PartialSnapshot: IDL.Null,
    IncrementalDiff: IDL.Null,
  });
  const BackupStatus = IDL.Variant({ Uploading: IDL.Null, Finalized: IDL.Null, Failed: IDL.Null });
  const BackupMetadata = IDL.Record({
    backupId: IDL.Text,
    dbType: IDL.Text,
    backupType: BackupType,
    parentBackupId: IDL.Opt(IDL.Text),
    totalSize: IDL.Nat,
    chunkCount: IDL.Nat,
    sha256: IDL.Text,
    createdAt: IDL.Int,
    createdBy: IDL.Principal,
    backupLabel: IDL.Opt(IDL.Text),
    status: BackupStatus,
  });

  return IDL.Service({
    init: IDL.Func([IDL.Principal], [], []),
    // Operator management
    createOperatorInvite: IDL.Func(
      [IDL.Text, OperatorPermissions],
      [IDL.Variant({ Ok: IDL.Text, Err: IDL.Text })],
      [],
    ),
    revokeOperator: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    listOperators: IDL.Func([], [IDL.Vec(OperatorRecord)], ['query']),
    updateOperatorPermissions: IDL.Func(
      [IDL.Principal, OperatorPermissions],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    registerOperator: IDL.Func(
      [IDL.Text],
      [IDL.Variant({ Ok: OperatorRecord, Err: IDL.Text })],
      [],
    ),
    rotateOperatorKey: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    // Guardian management
    addGuardian: IDL.Func(
      [IDL.Principal, IDL.Text, GuardianPermissions],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    removeGuardian: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    listGuardians: IDL.Func([], [IDL.Vec(GuardianRecord)], ['query']),
    createGuardianInvite: IDL.Func(
      [IDL.Text, GuardianPermissions],
      [IDL.Variant({ Ok: IDL.Text, Err: IDL.Text })],
      [],
    ),
    acceptGuardianInvite: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    approveGuardian: IDL.Func([IDL.Principal], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    checkGuardianStatus: IDL.Func(
      [],
      [IDL.Variant({ Ok: GuardianRecord, Err: IDL.Text })],
      ['query'],
    ),
    listOperatorsForGuardian: IDL.Func(
      [],
      [
        IDL.Vec(
          IDL.Record({
            principal: IDL.Principal,
            name: IDL.Text,
            status: IDL.Variant({ Active: IDL.Null, Revoked: IDL.Null, Expired: IDL.Null }),
          }),
        ),
      ],
      ['query'],
    ),
    guardianRevokeOperator: IDL.Func(
      [IDL.Principal],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    guardianFreezePayments: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    guardianPauseWrites: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    unfreezePayments: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    resumeWrites: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    // Owner-only
    setIdentityFile: IDL.Func(
      [IDL.Text, IDL.Text],
      [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })],
      [],
    ),
    deleteMemoryFile: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    rollbackMemory: IDL.Func(
      [IDL.Text, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    setConfig: IDL.Func([AgentConfig], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    setTransferAllowlist: IDL.Func(
      [IDL.Vec(Account)],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    setDailySpendingLimit: IDL.Func(
      [IDL.Principal, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    ownerWithdraw: IDL.Func([IDL.Text, IDL.Nat], [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })], []),
    fundTopUp: IDL.Func([IDL.Text, IDL.Nat], [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })], []),
    setTopUpLimits: IDL.Func(
      [IDL.Nat, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    getTopUpLimits: IDL.Func(
      [],
      [IDL.Record({ maxCkusdcE6s: IDL.Nat, cooldownSeconds: IDL.Nat })],
      ['query'],
    ),
    // Memory
    readMemory: IDL.Func([IDL.Text], [IDL.Variant({ Ok: MemoryFile, Err: IDL.Text })], ['query']),
    listMemoryFiles: IDL.Func(
      [],
      [IDL.Vec(IDL.Record({ path: IDL.Text, version: IDL.Nat, lastModifiedAt: IDL.Int }))],
      ['query'],
    ),
    appendMemory: IDL.Func([IDL.Text, IDL.Text], [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })], []),
    readMemoryBatch: IDL.Func(
      [IDL.Vec(IDL.Text)],
      [IDL.Vec(IDL.Tuple(IDL.Text, IDL.Variant({ Ok: MemoryFile, Err: IDL.Text })))],
      ['query'],
    ),
    getMemoryHistory: IDL.Func([IDL.Text], [IDL.Vec(MemoryVersion)], ['query']),
    // Sessions
    readSession: IDL.Func(
      [IDL.Text, IDL.Nat, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Vec(SessionMessage), Err: IDL.Text })],
      ['query'],
    ),
    appendSession: IDL.Func(
      [IDL.Text, IDL.Vec(SessionMessage)],
      [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })],
      [],
    ),
    deleteSession: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    listSessions: IDL.Func([], [IDL.Vec(SessionInfo)], ['query']),
    // Search
    searchKeyword: IDL.Func([IDL.Text, IDL.Nat], [IDL.Vec(SearchResult)], ['query']),
    // Config
    readConfig: IDL.Func([], [IDL.Variant({ Ok: AgentConfig, Err: IDL.Text })], ['query']),
    // Wallet
    walletBalance: IDL.Func([], [IDL.Variant({ Ok: IDL.Nat, Err: IDL.Text })], []),
    walletBalances: IDL.Func(
      [],
      [
        IDL.Variant({
          Ok: IDL.Record({
            cycles: IDL.Nat,
            icpE8s: IDL.Nat,
            ckusdcE6s: IDL.Nat,
            ckusdtE6s: IDL.Nat,
          }),
          Err: IDL.Text,
        }),
      ],
      [],
    ),
    remainingDailyAllowance: IDL.Func([], [IDL.Nat], ['query']),
    // Audit
    readAuditLog: IDL.Func([IDL.Nat, IDL.Nat], [IDL.Vec(AuditEntry)], ['query']),
    auditLogSize: IDL.Func([], [IDL.Nat], ['query']),
    // ERC-8004 Agent Identity
    initAgentIdentity: IDL.Func([], [IDL.Variant({ Ok: AgentIdentity, Err: IDL.Text })], []),
    getAgentIdentity: IDL.Func([], [IDL.Opt(AgentIdentity)], ['query']),
    signWithAgentKey: IDL.Func(
      [IDL.Vec(IDL.Nat8)],
      [IDL.Variant({ Ok: IDL.Vec(IDL.Nat8), Err: IDL.Text })],
      [],
    ),
    // x402 Payment
    createPaymentAuthorization: IDL.Func(
      [IDL.Text, IDL.Nat],
      [IDL.Variant({ Ok: PaymentAuthorization, Err: IDL.Text })],
      [],
    ),
    // World ID
    setWorldIdProof: IDL.Func([WorldIdProof], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    getWorldIdProof: IDL.Func([], [IDL.Opt(WorldIdProof)], ['query']),
    isWorldIdVerified: IDL.Func([], [IDL.Bool], ['query']),
    // Backup
    initBackup: IDL.Func(
      [IDL.Text, BackupType, IDL.Opt(IDL.Text), IDL.Text, IDL.Opt(IDL.Text)],
      [IDL.Variant({ Ok: IDL.Text, Err: IDL.Text })],
      [],
    ),
    pushBackupChunk: IDL.Func(
      [IDL.Text, IDL.Nat, IDL.Vec(IDL.Nat8)],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    finalizeBackup: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    abortBackup: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    listBackups: IDL.Func([IDL.Opt(IDL.Text)], [IDL.Vec(BackupMetadata)], ['query']),
    pullBackupChunk: IDL.Func(
      [IDL.Text, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Vec(IDL.Nat8), Err: IDL.Text })],
      ['query'],
    ),
    getBackupMetadata: IDL.Func(
      [IDL.Text],
      [IDL.Variant({ Ok: BackupMetadata, Err: IDL.Text })],
      ['query'],
    ),
    deleteBackup: IDL.Func([IDL.Text], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
    setBackupRetention: IDL.Func(
      [IDL.Text, IDL.Nat],
      [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })],
      [],
    ),
    // Cycles
    getCycleHistory: IDL.Func([], [IDL.Vec(IDL.Tuple(IDL.Int, IDL.Nat))], ['query']),
    // Status
    status: IDL.Func(
      [],
      [
        IDL.Record({
          owner: IDL.Opt(IDL.Principal),
          memoryFileCount: IDL.Nat,
          sessionCount: IDL.Nat,
          auditLogSize: IDL.Nat,
          operatorCount: IDL.Nat,
          cyclesBalance: IDL.Nat,
          version: IDL.Text,
          guardianCount: IDL.Nat,
          paymentsFrozen: IDL.Bool,
          writesPaused: IDL.Bool,
          backupCount: IDL.Nat,
          totalBackupSize: IDL.Nat,
          totalMemoryWrites: IDL.Nat,
          totalSessionAppends: IDL.Nat,
        }),
      ],
      ['query'],
    ),
    metrics: IDL.Func(
      [],
      [
        IDL.Record({
          totalMemoryReads: IDL.Nat,
          totalMemoryWrites: IDL.Nat,
          totalSessionAppends: IDL.Nat,
          totalSearches: IDL.Nat,
        }),
      ],
      ['query'],
    ),
    wasmHash: IDL.Func([], [IDL.Text], ['query']),
    getSpawnedBy: IDL.Func([], [IDL.Opt(IDL.Principal)], ['query']),
    returnToManaged: IDL.Func([], [IDL.Variant({ Ok: IDL.Null, Err: IDL.Text })], []),
  });
};

export function createAnonymousRegistryActor() {
  const agent = HttpAgent.createSync({
    host: IC_HOST,
    shouldFetchRootKey: isLocalHost(IC_HOST),
  });
  if (isLocalHost(IC_HOST)) {
    const originalCall = agent.call.bind(agent);
    agent.call = (canisterId: any, options: any, identity?: any) =>
      originalCall(canisterId, { ...options, callSync: false }, identity);
  }
  return Actor.createActor(registryIdlFactory, {
    agent,
    canisterId: REGISTRY_CANISTER_ID,
  });
}

export function createRegistryActor(agent: HttpAgent) {
  return Actor.createActor(registryIdlFactory, {
    agent,
    canisterId: REGISTRY_CANISTER_ID,
  });
}

export function createEngramActor(agent: HttpAgent, canisterId: string) {
  return Actor.createActor(engramIdlFactory, {
    agent,
    canisterId,
  });
}

// IC Management Canister — for direct controller management (sovereignty flow)
const IC_MANAGEMENT_CANISTER_ID = 'aaaaa-aa';

export const icManagementIdlFactory = ({ IDL }: { IDL: any }) => {
  const CanisterSettings = IDL.Record({
    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
    compute_allocation: IDL.Opt(IDL.Nat),
    memory_allocation: IDL.Opt(IDL.Nat),
    freezing_threshold: IDL.Opt(IDL.Nat),
  });
  const CanisterStatusResult = IDL.Record({
    status: IDL.Variant({ running: IDL.Null, stopping: IDL.Null, stopped: IDL.Null }),
    settings: IDL.Record({ controllers: IDL.Vec(IDL.Principal) }),
    module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),
    memory_size: IDL.Nat,
    cycles: IDL.Nat,
  });
  return IDL.Service({
    canister_status: IDL.Func(
      [IDL.Record({ canister_id: IDL.Principal })],
      [CanisterStatusResult],
      [],
    ),
    update_settings: IDL.Func(
      [IDL.Record({ canister_id: IDL.Principal, settings: CanisterSettings })],
      [],
      [],
    ),
  });
};

export function createManagementActor(agent: HttpAgent) {
  return Actor.createActor(icManagementIdlFactory, {
    agent,
    canisterId: IC_MANAGEMENT_CANISTER_ID,
    // Management canister calls must be routed via the target canister's
    // effective ID, otherwise the replica cannot locate the canister.
    callTransform: (_methodName: string, args: any[]) => ({
      effectiveCanisterId: args[0]?.canister_id,
    }),
  });
}

// ICP Ledger (ICRC-1) IDL factory — minimal subset for transfers
const ICP_LEDGER_CANISTER_ID =
  import.meta.env.VITE_ICP_LEDGER_CANISTER_ID ||
  (import.meta.env.DEV ? 'ryjl3-tyaaa-aaaaa-aaaba-cai' : 'ryjl3-tyaaa-aaaaa-aaaba-cai');

export const icpLedgerIdlFactory = ({ IDL }: { IDL: any }) => {
  const Account = IDL.Record({ owner: IDL.Principal, subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)) });
  const TransferArg = IDL.Record({
    from_subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)),
    to: Account,
    amount: IDL.Nat,
    fee: IDL.Opt(IDL.Nat),
    memo: IDL.Opt(IDL.Vec(IDL.Nat8)),
    created_at_time: IDL.Opt(IDL.Nat64),
  });
  const TransferError = IDL.Variant({
    BadFee: IDL.Record({ expected_fee: IDL.Nat }),
    BadBurn: IDL.Record({ min_burn_amount: IDL.Nat }),
    InsufficientFunds: IDL.Record({ balance: IDL.Nat }),
    TooOld: IDL.Null,
    CreatedInFuture: IDL.Record({ ledger_time: IDL.Nat64 }),
    Duplicate: IDL.Record({ duplicate_of: IDL.Nat }),
    TemporarilyUnavailable: IDL.Null,
    GenericError: IDL.Record({ error_code: IDL.Nat, message: IDL.Text }),
  });
  return IDL.Service({
    icrc1_balance_of: IDL.Func([Account], [IDL.Nat], ['query']),
    icrc1_transfer: IDL.Func([TransferArg], [IDL.Variant({ Ok: IDL.Nat, Err: TransferError })], []),
    icrc1_fee: IDL.Func([], [IDL.Nat], ['query']),
  });
};

export function createLedgerActor(agent: HttpAgent) {
  return Actor.createActor(icpLedgerIdlFactory, {
    agent,
    canisterId: ICP_LEDGER_CANISTER_ID,
  });
}

// ckUSDC Ledger (same ICRC-1 interface as ICP)
const CKUSDC_LEDGER_CANISTER_ID =
  import.meta.env.VITE_CKUSDC_LEDGER_CANISTER_ID || 'xevnm-gaaaa-aaaar-qafnq-cai';

export function createCkusdcLedgerActor(agent: HttpAgent) {
  return Actor.createActor(icpLedgerIdlFactory, {
    agent,
    canisterId: CKUSDC_LEDGER_CANISTER_ID,
  });
}

// ckUSDT Ledger (same ICRC-1 interface as ICP/ckUSDC)
const CKUSDT_LEDGER_CANISTER_ID =
  import.meta.env.VITE_CKUSDT_LEDGER_CANISTER_ID || 'cngnf-vqaaa-aaaar-qag4q-cai';

export function createCkusdtLedgerActor(agent: HttpAgent) {
  return Actor.createActor(icpLedgerIdlFactory, {
    agent,
    canisterId: CKUSDT_LEDGER_CANISTER_ID,
  });
}

// ICP Index Canister — for get_account_transactions
const ICP_INDEX_CANISTER_ID =
  import.meta.env.VITE_ICP_INDEX_CANISTER_ID || 'qhbym-qaaaa-aaaaa-aaafq-cai';

export const indexIdlFactory = ({ IDL }: { IDL: any }) => {
  const Account = IDL.Record({ owner: IDL.Principal, subaccount: IDL.Opt(IDL.Vec(IDL.Nat8)) });
  const Transaction = IDL.Record({
    kind: IDL.Text,
    mint: IDL.Opt(
      IDL.Record({
        amount: IDL.Nat,
        to: Account,
        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),
        created_at_time: IDL.Opt(IDL.Nat64),
      }),
    ),
    burn: IDL.Opt(
      IDL.Record({
        amount: IDL.Nat,
        from: Account,
        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),
        created_at_time: IDL.Opt(IDL.Nat64),
        spender: IDL.Opt(Account),
      }),
    ),
    transfer: IDL.Opt(
      IDL.Record({
        amount: IDL.Nat,
        from: Account,
        to: Account,
        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),
        created_at_time: IDL.Opt(IDL.Nat64),
        fee: IDL.Opt(IDL.Nat),
        spender: IDL.Opt(Account),
      }),
    ),
    approve: IDL.Opt(
      IDL.Record({
        amount: IDL.Nat,
        from: Account,
        spender: IDL.Opt(Account),
        memo: IDL.Opt(IDL.Vec(IDL.Nat8)),
        created_at_time: IDL.Opt(IDL.Nat64),
        fee: IDL.Opt(IDL.Nat),
        expected_allowance: IDL.Opt(IDL.Nat),
        expires_at: IDL.Opt(IDL.Nat64),
      }),
    ),
    timestamp: IDL.Nat64,
  });
  const TransactionWithId = IDL.Record({ id: IDL.Nat, transaction: Transaction });
  const GetAccountTransactionsArgs = IDL.Record({
    account: Account,
    start: IDL.Opt(IDL.Nat),
    max_results: IDL.Nat,
  });
  const GetAccountTransactionsResult = IDL.Variant({
    Ok: IDL.Record({
      transactions: IDL.Vec(TransactionWithId),
      oldest_tx_id: IDL.Opt(IDL.Nat),
      balance: IDL.Nat,
    }),
    Err: IDL.Record({ message: IDL.Text }),
  });
  return IDL.Service({
    get_account_transactions: IDL.Func(
      [GetAccountTransactionsArgs],
      [GetAccountTransactionsResult],
      ['query'],
    ),
  });
};

export function createIcpIndexActor(agent: HttpAgent) {
  return Actor.createActor(indexIdlFactory, {
    agent,
    canisterId: ICP_INDEX_CANISTER_ID,
  });
}

// ckUSDC Index Canister (same interface as ICP Index)
const CKUSDC_INDEX_CANISTER_ID = import.meta.env.VITE_CKUSDC_INDEX_CANISTER_ID || '';

export function createCkusdcIndexActor(agent: HttpAgent) {
  if (!CKUSDC_INDEX_CANISTER_ID) return null;
  return Actor.createActor(indexIdlFactory, {
    agent,
    canisterId: CKUSDC_INDEX_CANISTER_ID,
  });
}

// ckUSDT Index Canister (same interface as ICP/ckUSDC Index)
const CKUSDT_INDEX_CANISTER_ID = import.meta.env.VITE_CKUSDT_INDEX_CANISTER_ID || '';

export function createCkusdtIndexActor(agent: HttpAgent) {
  if (!CKUSDT_INDEX_CANISTER_ID) return null;
  return Actor.createActor(indexIdlFactory, {
    agent,
    canisterId: CKUSDT_INDEX_CANISTER_ID,
  });
}

// ckETH Minter — used to fetch ERC-20 helper contract address for Ethereum deposits
const CKETH_MINTER_CANISTER_ID =
  import.meta.env.VITE_CKETH_MINTER_CANISTER_ID || 'sv3dd-oaaaa-aaaar-qacoa-cai';

export const minterIdlFactory = ({ IDL }: { IDL: any }) => {
  const MinterInfo = IDL.Record({
    minter_address: IDL.Opt(IDL.Text),
    smart_contract_address: IDL.Opt(IDL.Text),
    eth_helper_contract_address: IDL.Opt(IDL.Text),
    erc20_helper_contract_address: IDL.Opt(IDL.Text),
    deposit_with_subaccount_helper_contract_address: IDL.Opt(IDL.Text),
    minimum_withdrawal_amount: IDL.Opt(IDL.Nat),
  });
  return IDL.Service({
    get_minter_info: IDL.Func([], [MinterInfo], []),
    smart_contract_address: IDL.Func([], [IDL.Text], ['query']),
  });
};

export function createMinterActor(agent: HttpAgent) {
  return Actor.createActor(minterIdlFactory, {
    agent,
    canisterId: CKETH_MINTER_CANISTER_ID,
  });
}

/**
 * Encode an IC principal as bytes32 hex for Ethereum helper contract calls.
 * Format: 0x + [length byte] + [principal raw bytes] + [zero padding to 32 bytes]
 */
export function principalToBytes32Hex(principalText: string): string {
  const principal = Principal.fromText(principalText);
  const rawBytes = principal.toUint8Array();
  const buf = new Uint8Array(32);
  buf[0] = rawBytes.length;
  buf.set(rawBytes, 1);
  return (
    '0x' +
    Array.from(buf)
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('')
  );
}
